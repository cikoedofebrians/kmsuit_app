// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'first_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$FirstEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() checkPalindrome,
    required TResult Function(String newValue) onChangePalindromeText,
    required TResult Function(String newValue) onChangeNameText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? checkPalindrome,
    TResult? Function(String newValue)? onChangePalindromeText,
    TResult? Function(String newValue)? onChangeNameText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? checkPalindrome,
    TResult Function(String newValue)? onChangePalindromeText,
    TResult Function(String newValue)? onChangeNameText,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CheckPalindromeEvent value) checkPalindrome,
    required TResult Function(OnChangePalindromeTextEvent value)
        onChangePalindromeText,
    required TResult Function(OnChangeNameTextEvent value) onChangeNameText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CheckPalindromeEvent value)? checkPalindrome,
    TResult? Function(OnChangePalindromeTextEvent value)?
        onChangePalindromeText,
    TResult? Function(OnChangeNameTextEvent value)? onChangeNameText,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CheckPalindromeEvent value)? checkPalindrome,
    TResult Function(OnChangePalindromeTextEvent value)? onChangePalindromeText,
    TResult Function(OnChangeNameTextEvent value)? onChangeNameText,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FirstEventCopyWith<$Res> {
  factory $FirstEventCopyWith(
          FirstEvent value, $Res Function(FirstEvent) then) =
      _$FirstEventCopyWithImpl<$Res, FirstEvent>;
}

/// @nodoc
class _$FirstEventCopyWithImpl<$Res, $Val extends FirstEvent>
    implements $FirstEventCopyWith<$Res> {
  _$FirstEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$CheckPalindromeEventImplCopyWith<$Res> {
  factory _$$CheckPalindromeEventImplCopyWith(_$CheckPalindromeEventImpl value,
          $Res Function(_$CheckPalindromeEventImpl) then) =
      __$$CheckPalindromeEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$CheckPalindromeEventImplCopyWithImpl<$Res>
    extends _$FirstEventCopyWithImpl<$Res, _$CheckPalindromeEventImpl>
    implements _$$CheckPalindromeEventImplCopyWith<$Res> {
  __$$CheckPalindromeEventImplCopyWithImpl(_$CheckPalindromeEventImpl _value,
      $Res Function(_$CheckPalindromeEventImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$CheckPalindromeEventImpl implements CheckPalindromeEvent {
  const _$CheckPalindromeEventImpl();

  @override
  String toString() {
    return 'FirstEvent.checkPalindrome()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CheckPalindromeEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() checkPalindrome,
    required TResult Function(String newValue) onChangePalindromeText,
    required TResult Function(String newValue) onChangeNameText,
  }) {
    return checkPalindrome();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? checkPalindrome,
    TResult? Function(String newValue)? onChangePalindromeText,
    TResult? Function(String newValue)? onChangeNameText,
  }) {
    return checkPalindrome?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? checkPalindrome,
    TResult Function(String newValue)? onChangePalindromeText,
    TResult Function(String newValue)? onChangeNameText,
    required TResult orElse(),
  }) {
    if (checkPalindrome != null) {
      return checkPalindrome();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CheckPalindromeEvent value) checkPalindrome,
    required TResult Function(OnChangePalindromeTextEvent value)
        onChangePalindromeText,
    required TResult Function(OnChangeNameTextEvent value) onChangeNameText,
  }) {
    return checkPalindrome(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CheckPalindromeEvent value)? checkPalindrome,
    TResult? Function(OnChangePalindromeTextEvent value)?
        onChangePalindromeText,
    TResult? Function(OnChangeNameTextEvent value)? onChangeNameText,
  }) {
    return checkPalindrome?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CheckPalindromeEvent value)? checkPalindrome,
    TResult Function(OnChangePalindromeTextEvent value)? onChangePalindromeText,
    TResult Function(OnChangeNameTextEvent value)? onChangeNameText,
    required TResult orElse(),
  }) {
    if (checkPalindrome != null) {
      return checkPalindrome(this);
    }
    return orElse();
  }
}

abstract class CheckPalindromeEvent implements FirstEvent {
  const factory CheckPalindromeEvent() = _$CheckPalindromeEventImpl;
}

/// @nodoc
abstract class _$$OnChangePalindromeTextEventImplCopyWith<$Res> {
  factory _$$OnChangePalindromeTextEventImplCopyWith(
          _$OnChangePalindromeTextEventImpl value,
          $Res Function(_$OnChangePalindromeTextEventImpl) then) =
      __$$OnChangePalindromeTextEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String newValue});
}

/// @nodoc
class __$$OnChangePalindromeTextEventImplCopyWithImpl<$Res>
    extends _$FirstEventCopyWithImpl<$Res, _$OnChangePalindromeTextEventImpl>
    implements _$$OnChangePalindromeTextEventImplCopyWith<$Res> {
  __$$OnChangePalindromeTextEventImplCopyWithImpl(
      _$OnChangePalindromeTextEventImpl _value,
      $Res Function(_$OnChangePalindromeTextEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? newValue = null,
  }) {
    return _then(_$OnChangePalindromeTextEventImpl(
      null == newValue
          ? _value.newValue
          : newValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$OnChangePalindromeTextEventImpl implements OnChangePalindromeTextEvent {
  const _$OnChangePalindromeTextEventImpl(this.newValue);

  @override
  final String newValue;

  @override
  String toString() {
    return 'FirstEvent.onChangePalindromeText(newValue: $newValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OnChangePalindromeTextEventImpl &&
            (identical(other.newValue, newValue) ||
                other.newValue == newValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, newValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OnChangePalindromeTextEventImplCopyWith<_$OnChangePalindromeTextEventImpl>
      get copyWith => __$$OnChangePalindromeTextEventImplCopyWithImpl<
          _$OnChangePalindromeTextEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() checkPalindrome,
    required TResult Function(String newValue) onChangePalindromeText,
    required TResult Function(String newValue) onChangeNameText,
  }) {
    return onChangePalindromeText(newValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? checkPalindrome,
    TResult? Function(String newValue)? onChangePalindromeText,
    TResult? Function(String newValue)? onChangeNameText,
  }) {
    return onChangePalindromeText?.call(newValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? checkPalindrome,
    TResult Function(String newValue)? onChangePalindromeText,
    TResult Function(String newValue)? onChangeNameText,
    required TResult orElse(),
  }) {
    if (onChangePalindromeText != null) {
      return onChangePalindromeText(newValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CheckPalindromeEvent value) checkPalindrome,
    required TResult Function(OnChangePalindromeTextEvent value)
        onChangePalindromeText,
    required TResult Function(OnChangeNameTextEvent value) onChangeNameText,
  }) {
    return onChangePalindromeText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CheckPalindromeEvent value)? checkPalindrome,
    TResult? Function(OnChangePalindromeTextEvent value)?
        onChangePalindromeText,
    TResult? Function(OnChangeNameTextEvent value)? onChangeNameText,
  }) {
    return onChangePalindromeText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CheckPalindromeEvent value)? checkPalindrome,
    TResult Function(OnChangePalindromeTextEvent value)? onChangePalindromeText,
    TResult Function(OnChangeNameTextEvent value)? onChangeNameText,
    required TResult orElse(),
  }) {
    if (onChangePalindromeText != null) {
      return onChangePalindromeText(this);
    }
    return orElse();
  }
}

abstract class OnChangePalindromeTextEvent implements FirstEvent {
  const factory OnChangePalindromeTextEvent(final String newValue) =
      _$OnChangePalindromeTextEventImpl;

  String get newValue;
  @JsonKey(ignore: true)
  _$$OnChangePalindromeTextEventImplCopyWith<_$OnChangePalindromeTextEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$OnChangeNameTextEventImplCopyWith<$Res> {
  factory _$$OnChangeNameTextEventImplCopyWith(
          _$OnChangeNameTextEventImpl value,
          $Res Function(_$OnChangeNameTextEventImpl) then) =
      __$$OnChangeNameTextEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String newValue});
}

/// @nodoc
class __$$OnChangeNameTextEventImplCopyWithImpl<$Res>
    extends _$FirstEventCopyWithImpl<$Res, _$OnChangeNameTextEventImpl>
    implements _$$OnChangeNameTextEventImplCopyWith<$Res> {
  __$$OnChangeNameTextEventImplCopyWithImpl(_$OnChangeNameTextEventImpl _value,
      $Res Function(_$OnChangeNameTextEventImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? newValue = null,
  }) {
    return _then(_$OnChangeNameTextEventImpl(
      null == newValue
          ? _value.newValue
          : newValue // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$OnChangeNameTextEventImpl implements OnChangeNameTextEvent {
  const _$OnChangeNameTextEventImpl(this.newValue);

  @override
  final String newValue;

  @override
  String toString() {
    return 'FirstEvent.onChangeNameText(newValue: $newValue)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OnChangeNameTextEventImpl &&
            (identical(other.newValue, newValue) ||
                other.newValue == newValue));
  }

  @override
  int get hashCode => Object.hash(runtimeType, newValue);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$OnChangeNameTextEventImplCopyWith<_$OnChangeNameTextEventImpl>
      get copyWith => __$$OnChangeNameTextEventImplCopyWithImpl<
          _$OnChangeNameTextEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() checkPalindrome,
    required TResult Function(String newValue) onChangePalindromeText,
    required TResult Function(String newValue) onChangeNameText,
  }) {
    return onChangeNameText(newValue);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? checkPalindrome,
    TResult? Function(String newValue)? onChangePalindromeText,
    TResult? Function(String newValue)? onChangeNameText,
  }) {
    return onChangeNameText?.call(newValue);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? checkPalindrome,
    TResult Function(String newValue)? onChangePalindromeText,
    TResult Function(String newValue)? onChangeNameText,
    required TResult orElse(),
  }) {
    if (onChangeNameText != null) {
      return onChangeNameText(newValue);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(CheckPalindromeEvent value) checkPalindrome,
    required TResult Function(OnChangePalindromeTextEvent value)
        onChangePalindromeText,
    required TResult Function(OnChangeNameTextEvent value) onChangeNameText,
  }) {
    return onChangeNameText(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(CheckPalindromeEvent value)? checkPalindrome,
    TResult? Function(OnChangePalindromeTextEvent value)?
        onChangePalindromeText,
    TResult? Function(OnChangeNameTextEvent value)? onChangeNameText,
  }) {
    return onChangeNameText?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(CheckPalindromeEvent value)? checkPalindrome,
    TResult Function(OnChangePalindromeTextEvent value)? onChangePalindromeText,
    TResult Function(OnChangeNameTextEvent value)? onChangeNameText,
    required TResult orElse(),
  }) {
    if (onChangeNameText != null) {
      return onChangeNameText(this);
    }
    return orElse();
  }
}

abstract class OnChangeNameTextEvent implements FirstEvent {
  const factory OnChangeNameTextEvent(final String newValue) =
      _$OnChangeNameTextEventImpl;

  String get newValue;
  @JsonKey(ignore: true)
  _$$OnChangeNameTextEventImplCopyWith<_$OnChangeNameTextEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$FirstState {
  String get name => throw _privateConstructorUsedError;
  String get palindrome => throw _privateConstructorUsedError;
  String get palindromeMessage => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $FirstStateCopyWith<FirstState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $FirstStateCopyWith<$Res> {
  factory $FirstStateCopyWith(
          FirstState value, $Res Function(FirstState) then) =
      _$FirstStateCopyWithImpl<$Res, FirstState>;
  @useResult
  $Res call({String name, String palindrome, String palindromeMessage});
}

/// @nodoc
class _$FirstStateCopyWithImpl<$Res, $Val extends FirstState>
    implements $FirstStateCopyWith<$Res> {
  _$FirstStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? palindrome = null,
    Object? palindromeMessage = null,
  }) {
    return _then(_value.copyWith(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      palindrome: null == palindrome
          ? _value.palindrome
          : palindrome // ignore: cast_nullable_to_non_nullable
              as String,
      palindromeMessage: null == palindromeMessage
          ? _value.palindromeMessage
          : palindromeMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$FirstStateImplCopyWith<$Res>
    implements $FirstStateCopyWith<$Res> {
  factory _$$FirstStateImplCopyWith(
          _$FirstStateImpl value, $Res Function(_$FirstStateImpl) then) =
      __$$FirstStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String name, String palindrome, String palindromeMessage});
}

/// @nodoc
class __$$FirstStateImplCopyWithImpl<$Res>
    extends _$FirstStateCopyWithImpl<$Res, _$FirstStateImpl>
    implements _$$FirstStateImplCopyWith<$Res> {
  __$$FirstStateImplCopyWithImpl(
      _$FirstStateImpl _value, $Res Function(_$FirstStateImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? name = null,
    Object? palindrome = null,
    Object? palindromeMessage = null,
  }) {
    return _then(_$FirstStateImpl(
      name: null == name
          ? _value.name
          : name // ignore: cast_nullable_to_non_nullable
              as String,
      palindrome: null == palindrome
          ? _value.palindrome
          : palindrome // ignore: cast_nullable_to_non_nullable
              as String,
      palindromeMessage: null == palindromeMessage
          ? _value.palindromeMessage
          : palindromeMessage // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$FirstStateImpl implements _FirstState {
  const _$FirstStateImpl(
      {this.name = "", this.palindrome = "", this.palindromeMessage = ""});

  @override
  @JsonKey()
  final String name;
  @override
  @JsonKey()
  final String palindrome;
  @override
  @JsonKey()
  final String palindromeMessage;

  @override
  String toString() {
    return 'FirstState(name: $name, palindrome: $palindrome, palindromeMessage: $palindromeMessage)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FirstStateImpl &&
            (identical(other.name, name) || other.name == name) &&
            (identical(other.palindrome, palindrome) ||
                other.palindrome == palindrome) &&
            (identical(other.palindromeMessage, palindromeMessage) ||
                other.palindromeMessage == palindromeMessage));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, name, palindrome, palindromeMessage);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FirstStateImplCopyWith<_$FirstStateImpl> get copyWith =>
      __$$FirstStateImplCopyWithImpl<_$FirstStateImpl>(this, _$identity);
}

abstract class _FirstState implements FirstState {
  const factory _FirstState(
      {final String name,
      final String palindrome,
      final String palindromeMessage}) = _$FirstStateImpl;

  @override
  String get name;
  @override
  String get palindrome;
  @override
  String get palindromeMessage;
  @override
  @JsonKey(ignore: true)
  _$$FirstStateImplCopyWith<_$FirstStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
